The aim of this optional task is to integrate the texture mapping function that you _might_ have implemented in a previous workbook into your 3D rasteriser. If you didn't implement the texture mapping function previously, or are behind with the workbook tasks, then you might like to skip this current task. Don't worry - if you are doing the coursework for this unit, you will have the opportunity to revisit texture mapping at a later date.

Take a look at the slides and audio narration above for more information on how OBJ files handle textures. Use this knowledge to extend your file parsing functions to read and then store the additional texture information. Note that the `ModelTriangle` class contains an array of `TexturePoints` to help you maintain the relationship between triangle vertices and texture point coordinates.

Rather than drawing the floor of the Cornell Box model as two plain green triangles, you should texture these triangles using our usual <a href="models/texture.ppm" target="_blank">texture image</a>. To help you in this task, we have provided an <a href="models/textured-cornell-box.mtl" target="_blank">updated OBJ materials file</a> and an <a href="models/textured-cornell-box.obj" target="_blank">updated OBJ geometry file</a> both of which contain additional texture information (namely: a new textured material called "Cobbles", texture mapping points for some of the vertices in the model and a reference to the texture image filename).

Try to get your render looking _similar_ to that shown in the diagram below. Don't spend too long trying to get the textured floor looking _exactly_ right (because you'll never actually manage to do it ;o) You might have an intuition that something isn't _quite_ right with this approach to texture mapping in 3D. Try not to worry too much about this for the moment - we will return to the topic of texture mapping in a later workbook (spoiler: the problem relates to depth and perspective !)